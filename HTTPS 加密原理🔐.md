## HTTPS 加密原理🔐

前端早读课：https://mp.weixin.qq.com/s/I5yezHTrObblrBGAoAEGkQ



#### 一、对称加密

双方各自持有一个密钥（服务器将密钥传输给浏览器），通信过程中都使用密钥加密通信内容

<img src="https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0MevjBYJibu4mdZnvERhft9rFz0fRBxl7SkfngKhAjRz2OGxALQ6uVqdia3qjlBicdruexGesTjtdNoXpcw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:70%;" />

优点：简单易行

缺点：密钥被劫持后易被破解



#### 二、非对称加密

两把密钥，一把公钥，一把私钥，**用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开**

<img src="https://mmbiz.qpic.cn/mmbiz_png/meG6Vo0MevjBYJibu4mdZnvERhft9rFz0emVXiaCQ1lwQvHrC5ibeu2bXicQT4OziaWmAv3rQZp0y4icRYo73197MZoQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image" style="zoom:67%;" />

思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开公钥加密的数据。

过程：

- 服务器将公钥以明文方式传输给浏览器（公钥会被劫持）
- 浏览器向服务器传输数据，先用公钥加密，服务器接收后使用私钥解密
- 服务器向浏览器传输数据，先用私钥加密，服务器接收后使用公钥解密（公钥若被劫持，信息将泄漏）

缺点：公钥会被劫持





#### 三、改良的非对称加密

我们已经理解通过一组公钥私钥，可以保证单个方向传输的安全性（如二），那用两组公钥私钥，是否就能保证双向传输都安全了？请看下面的过程：

- 某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。
- 浏览器把公钥B明文传输给服务器。
- 服务器把公钥A明文给传输浏览器。
- 之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。
- 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。

缺点：非对称加密算法非常耗时（对称加密快很多）





#### 四、非对称加密+对称加密

既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，且非对称加密、解密各只需用一次即可。

请看一下这个过程：

- 某网站拥有用于非对称加密的公钥A、私钥A’。
- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。
- 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

漏洞：中间劫持人拦截

- 某网站有用于非对称加密的公钥A、私钥A’。

- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。

- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。

- 浏览器生成一个用于对称加密的密钥X，用公钥B（浏览器无法得知公钥被替换了）加密后传给服务器。

- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。

- 服务器拿到后用私钥A’解密得到密钥X。

  

  这样在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X。根本原因是浏览器无法确认收到的公钥是不是网站自己的，因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？



#### 五、如何证明浏览器收到的公钥一定是该网站的公钥？

#### （1）数字证书

网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了

#### （2）数字签名

数字签名的制作过程：

- CA机构拥有非对称加密的私钥和公钥。

- CA机构对证书明文数据T进行hash。

- 对hash后的值用私钥加密，得到数字签名S。

  明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。

  浏览器验证过程：

  - 拿到证书，得到明文T，签名S。
  - 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥），得到S’。
  - 用证书里指明的hash算法对明文T进行hash得到T’。
  - 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。